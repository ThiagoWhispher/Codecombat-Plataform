{"version":3,"sources":["app/lib/HtmlExtractor.coffee"],"names":[],"mappings":"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","file":"public/javascripts/app/lib/HtmlExtractor.js","sourcesContent":["# Convert htmlparser2-formatted DOM structure into Deku format\r\ndekuify = (elem) ->\r\n  return elem.data if elem.type is 'text'\r\n  return null if elem.type is 'comment'  # TODO: figure out how to make a comment in virtual dom\r\n  # Prevent Deku from including invalid attribute names (which DOMElement will choke on)\r\n  elem.attribs = _.omit elem.attribs, (val, attr) -> not attr.match(/^[^\\s\"'<>\\\\\\/=]+$/)\r\n  unless elem.name\r\n    console.log('Failed to dekuify', elem)\r\n    return elem.type\r\n  deku.element(elem.name, elem.attribs, (dekuify(c) for c in elem.children ? []))\r\n\r\n# Convert Deku-formatted DOM nodes into a flat list of their raw values\r\nunwrapDekuNodes = (dekuNode) ->\r\n  return dekuNode if _.isString(dekuNode)\r\n  if _.isArray(dekuNode)\r\n    return _.filter _.flatten(unwrapDekuNodes(child) for child in dekuNode)\r\n  else\r\n    return _.filter _.flatten [dekuNode.nodeValue, (unwrapDekuNodes(child) for child in (dekuNode.children or []))]\r\n\r\n# Parses user code into Deku format. Also guarantees an `html` and `body` element so that Deku doesn't explode when reading it.\r\n# Arguments:\r\n#   html — Raw HTML source code, possibly without html/body tags\r\n# Returns: Parsed Deku-format DOM that includes html/body tags\r\nparseUserHtml = (html) ->\r\n  dom = htmlparser2.parseDOM html, {}\r\n  bodyNode = _.find(dom, name: 'body') ? {name: 'body', attribs: null, children: dom}\r\n  htmlNode = _.find(dom, name: 'html') ? {name: 'html', attribs: null, children: [bodyNode]}\r\n  dekuify(htmlNode)\r\n\r\n# Creates a deku virtual DOM for given HTML, with the <script> and <style> tags separated out (and dekuified as well)\r\n# Arguments:\r\n#   html — raw HTML source code\r\n# Returns: Object\r\n#   virtualDom: The DekuTree for the main content\r\n#   scripts: A list of Deku nodes for the <script> tags\r\n#   styles: A list of Deku nodes for the <style> tags\r\nextractStylesAndScripts = (html) ->\r\n  dekuTree = parseUserHtml(html)\r\n  recurse = (dekuTree) ->\r\n    #base case\r\n    if dekuTree.type is '#text'\r\n      return { virtualDom: dekuTree, styles: [], scripts: [] }\r\n    if dekuTree.type is 'style'\r\n      return { styles: [dekuTree], scripts: [] }\r\n    if dekuTree.type is 'script'\r\n      return { styles: [], scripts: [dekuTree] }\r\n    # recurse over children\r\n    childStyles = []\r\n    childScripts = []\r\n    dekuTree.children?.forEach (dekuChild, index) =>\r\n      { virtualDom, styles, scripts } = recurse(dekuChild)\r\n      dekuTree.children[index] = virtualDom\r\n      childStyles = childStyles.concat(styles)\r\n      childScripts = childScripts.concat(scripts)\r\n    dekuTree.children = _.filter dekuTree.children # Remove the nodes we extracted\r\n    return { virtualDom: dekuTree, scripts: childScripts, styles: childStyles }\r\n\r\n  { virtualDom, scripts, styles } = recurse(dekuTree)\r\n  wrappedStyles = deku.element('head', {}, styles)\r\n  wrappedScripts = deku.element('head', {}, scripts)\r\n  return { virtualDom, scripts: wrappedScripts, styles: wrappedStyles }\r\n\r\n# Returns a list of CSS selectors found in CSS code and jQuery calls\r\nextractCssSelectors = (dekuStyles, dekuScripts) ->\r\n  cssSelectors = extractSelectorsFromCss dekuStyles\r\n  jQuerySelectors = extractSelectorsFromJS dekuScripts\r\n  return cssSelectors.concat(jQuerySelectors)\r\n\r\n# Returns a list of CSS selectors found in jQuery calls\r\n# Arguments:\r\n#   styles — one (or a list of) strings or Deku nodes.\r\nextractSelectorsFromCss = (styles) ->\r\n  styles = unwrapDekuNodes(styles)\r\n  styles = [styles] unless _.isArray(styles)\r\n  cssSelectors = _.flatten styles.map (rawCss) ->\r\n    try\r\n      parsedCss = parseCss(rawCss) # TODO: Don't put this in the global namespace\r\n      parsedCss.stylesheet.rules.map (rule) ->\r\n        rule.selectors.join(', ').trim()\r\n    catch e\r\n      # TODO: Report this error, handle CSS errors in general\r\n      []\r\n  cssSelectors\r\n\r\n# Returns a list of CSS selector strings found in jQuery calls\r\n# Arguments:\r\n#   scripts — one (or a list of) strings or Deku nodes.\r\nextractSelectorsFromJS = (scripts) ->\r\n  scripts = unwrapDekuNodes(scripts)\r\n  scripts = [scripts] unless _.isArray(scripts)\r\n  jQuerySelectors = _.flatten scripts.map (script) ->\r\n    (script.match(/\\$\\(\\s*['\"](?!<)(.*?)(?!>)['\"]\\s*\\)/g) or []).map (jQueryCall) ->\r\n      # Extract the argument (because capture groups don't work with /g)\r\n      jQueryCall.match(/\\$\\(\\s*['\"](?!<)(.*?)(?!>)['\"]\\s*\\)/)[1]\r\n  jQuerySelectors\r\n\r\n# Converts deku style nodes into a list of lines of CSS code.\r\n# Used to prefilter hovered lines for selectors.\r\nextractCssLines = (dekuStyles) ->\r\n  rawCssLines = []\r\n  dekuStyles.children.forEach (styleNode) =>\r\n    rawCss = styleNode.children[0].nodeValue\r\n    rawCssLines = rawCssLines.concat(rawCss.split('\\n'))\r\n  rawCssLines\r\n\r\n# Converts deku script nodes into a list of lines of lines of code that contain jQuery selectors\r\n# Used to prefilter hovered lines for selectors.\r\nextractJQueryLines = (dekuScripts) ->\r\n  _.flatten dekuScripts.children.map (dekuScript) ->\r\n    rawScript = dekuScript.children[0].nodeValue\r\n    _.filter (rawScript.split('\\n').map (line) -> (line.match(/^.*\\$\\(\\s*['\"].*['\"]\\s*\\).*$/g) or [])[0])\r\n\r\nmodule.exports = {\r\n  dekuify\r\n  unwrapDekuNodes\r\n  parseUserHtml\r\n  extractStylesAndScripts\r\n  extractCssSelectors\r\n  extractSelectorsFromCss\r\n  extractSelectorsFromJS\r\n  extractCssLines\r\n  extractJQueryLines\r\n}\r\n"]}